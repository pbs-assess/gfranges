---
title: "Distanced-based VOCC analysis"
author: "Philina English"
date: '2019-05-14'
output: html_document
---


```{r setup, include=FALSE}
# install.packages("yaImpute") # install package for k-nearest neighbour (kNN) search
# install.packages("raster") # required for calcslope + all raster functions
# install.package(gfplot) # required for some plotting and data functions

library(dplyr)
library(ggplot2)
library(sdmTMB)
library(gfranges)
```

Retrieve raw data
```{r}
all_depth <- readRDS("../tmb-sensor-explore/data/dat-sensor-trawl-all-depth.rds")

# add and scale predictors after filtering for survey(s) of interest
data <- all_depth$data %>%
  filter(depth_m>10) %>% # removes data if sensor stayed too near surface
  # filter(ssid != 1) %>%
  # filter(ssid != 3) %>%
  # filter(ssid != 4) %>%
  # filter(ssid != 16) %>%
  gfplot:::scale_survey_predictors()

data <- data[data$fishing_event_id != 481861, ]
# add any new predictors
# data <- data %>%
#   dplyr::mutate(
#   DOY = lubridate::yday(date),
#   shallow = ifelse(depth > 35, 0, 1)
# )
```

Or use old data 
```{r eval=FALSE}
data <- readRDS("../tmb-sensor-explore/data/sensor-data-processed.rds")
data <- data %>% mutate(depth = depth_m) %>% 
  filter(depth_m >10) %>% # removes data if sensor stayed too near surface
  gfplot:::scale_survey_predictors()

data <- data[data$fishing_event_id != 481861, ]
```


Create prediction grids for each survey area so that only years with data are included
```{r}
# choose base year(s) to create grid from
dummy_year <- c(2004, 2005)

# create grids for each ssid separately 
ssid <- 1
survey_abbrev <- "SYN QCS"
nd_1 <- spatiotemporal_grid(data, ssid, survey_abbrev, dummy_year)
unique(nd_1$year)

ssid <- 3
survey_abbrev <- "SYN HS"
nd_3 <- spatiotemporal_grid(data, ssid, survey_abbrev, dummy_year)
unique(nd_3$year)

ssid <- 4
survey_abbrev <- "SYN WCVI"
nd_4 <- spatiotemporal_grid(data, ssid, survey_abbrev, dummy_year)
unique(nd_4$year)

ssid <- 16
survey_abbrev <- "SYN WCHG"
nd_16 <- spatiotemporal_grid(data, ssid, survey_abbrev, dummy_year = 2006)
unique(nd_16$year)

nd <- rbind(nd_1, nd_3, nd_4, nd_16)
# nd <- nd_4 # for faster test option
nd <- nd %>% dplyr::mutate(shallow = ifelse(depth > 35, 0, 1))
```

Run sdmTMB model (if not done previously).
```{r eval=FALSE}
# # choose the spatial range to model
dat <- data %>% dplyr::filter(year > 2003) %>% select(year, ssid, X, Y, temperature_c, depth_scaled, depth_scaled2)
nd <- nd #%>% filter(ssid == 4)
 
spde <- sdmTMB::make_spde(dat$X, dat$Y, n_knots = 500)
sdmTMB::plot_spde(spde)

m_temp <- sdmTMB::sdmTMB(dat,
  temperature_c ~ 0 + as.factor(year),
  time_varying = ~ 0 + depth_scaled + depth_scaled2,
  time = "year", spde = spde,
  family = gaussian(link = "identity"),
  ar1_fields = TRUE, # maybe TRUE is better for all areas combined?
  include_spatial = TRUE,
  silent = FALSE
)

# stopifnot(m_temp$model$convergence == 0L)
# m_temp
# # Warning messages:
# #   1: In doTryCatch(return(expr), name, parentenv, handler) :
# #   restarting interrupted promise evaluation
# 
# saveRDS(m_temp, file = "data/m_temp_post2003.rds")
saveRDS(m_temp, file = "data/m_temp_allyears.rds")
```

Calculate predicted values
```{r}
m_temp <- readRDS("../VOCC/data/m_temp_post2003.rds")
# m_temp <- readRDS("../VOCC/data/m_temp_allyears.rds")

# can also be filtered to include only year with multiple surveys 
# m_temp <- readRDS("../VOCC/data/m_temp_allpost2003.rds")
# nd <- nd %>% dplyr::filter(year > 2003)
nd <- nd # %>% filter(ssid == 4)

predictions <- predict(m_temp, newdata = nd)

plot_map <- function(dat, column = "est") {
  ggplot(dat, aes_string("X", "Y", fill = column)) +
    geom_raster() +
    facet_wrap(~year) +
    coord_fixed()
}

p <- plot_map(predictions , "est") +
  scale_fill_viridis_c(trans = "sqrt", option = "C") +
  ggtitle("Prediction (fixed effects + all random effects)")
print(p)
```
```{r}
# choose the spatial range to build raster on
predicted1 <- predictions %>% filter(ssid == 1) 
predicted3 <- predictions %>% filter(ssid == 3) 
predicted4 <- predictions %>% filter(ssid == 4) 
predicted16 <- predictions %>% filter(ssid == 16) 
predicted1n3 <- predictions %>% filter(ssid != 16) %>% filter(ssid != 4) %>% filter(year > 2004) 

p <- plot_map(predicted1n3 , "est") +
  scale_fill_viridis_c(trans = "sqrt", option = "C") +
  ggtitle("Prediction (fixed effects + all random effects)")
print(p)
```


```{r}

# scale_fac = 2 means that the raster is reprojected to 2 X original grid (2 km)
rbrick <- make_raster_brick(predicted3, scale_fac = 2)
saveRDS(rbrick, file = "analysis/data/rbrick-temp-hs.rds")

# scale_fac = 2 means that the raster is reprojected to 2 X original grid (2 km)
rbrick <- make_raster_brick(predicted1, scale_fac = 2)
saveRDS(rbrick, file = "analysis/data/rbrick-temp-qcs.rds")

# scale_fac = 2 means that the raster is reprojected to 2 X original grid (2 km)
rbrick <- make_raster_brick(predicted4, scale_fac = 2)
saveRDS(rbrick, file = "analysis/data/rbrick-temp-wcvi.rds")

# scale_fac = 2 means that the raster is reprojected to 2 X original grid (2 km)
rbrick <- make_raster_brick(predicted16, scale_fac = 2)
saveRDS(rbrick, file = "analysis/data/rbrick-temp-wchg.rds")

rbrick <- make_raster_brick(predicted1n3, scale_fac = 2)
saveRDS(rbrick, file = "analysis/data/rbrick-temp-hs-qcs.rds")

```


```{r}

make_vector_data <- function(climate_data, 
  ssid = NULL,
  start_year = NULL,
  input_cell_size = 2, 
  scale_fac = 2,
  delta_t_total = 10,
  delta_t_step = 2,
  time_slices = 7, 
  indices = c(1, 1, 2, 2, 2, 3, 3),
  thresholds = c(0.75)
  ) {
#browser()
if (!is.null(ssid)) climate_data <- climate_data[climate_data$ssid %in% ssid, ]
if (!is.null(start_year)) climate_data <- climate_data %>% dplyr::filter(year >= start_year)

#if (!identical(time_slices, length(indices)))
  length_indices <- length(indices)
  if(!isTRUE(time_slices==length_indices))
      stop("Must have an indice assigned to each time slice,",
      "therefore length('indices') must equal 'time_slices'.",
      call. = FALSE)

#FIXME: need way of determining how many variables(in separate dataframes) are in dataset  
#if (!is.list(climate_data)) {
# if (length(thresholds) > 1)
#       stop("If multiple climate variables (and corresponding thresholds),", 
#         "data must be in list form.", call. = FALSE)

rbrick <- make_raster_brick(climate_data, scale_fac = scale_fac)
mnraster_brick <- raster::stackApply(rbrick, indices = indices, fun = mean)
start_raster <- mnraster_brick[[1]]
end_raster <- mnraster_brick[[3]]

# make sparate named lists containing climate rasters or dataframes
# data with just one climate variable
start_data <- list(var_1 = start_raster)
end_data <- list(var_1 = end_raster)

# } else {
#     if (!identical(length(climate_data), length(thresholds)))
#       stop("Must have a 'thresholds' value for each climate variable", call. = FALSE)
# rbrick <- list()
# for (i in seq_len(climate_data)) {
#   
# rbrick[[i]] <- make_raster_brick(climate_data[[i]], scale_fac = scale_fac)
# mnraster_brick <- raster::stackApply(rbrick[[i]], indices = indices, fun = mean)
# 
# start_raster <- mnraster_brick[[1]]
# end_raster <- mnraster_brick[[3]]
# var <- list(start_raster = start_raster, end_raster = end_raster)
# }

# start_data <- list(var = var$start_raster[[i]])
# end_data <- list(var = var$end_raster[[i]])
#}

start_data #
end_data  #
  
out <- dist_based_vocc(
  start_data = start_data,
  end_data = end_data,
  x = "x",
  y = "y",
  variable_names = c("index_1"), # what the layer within each element is called
  thresholds = thresholds,
  cell_size =  input_cell_size*scal_fac,
  delta_t = delta_t_total,
  raster = TRUE
  )

# FIXME: need to change function to deal with different time steps within a brick
slopedat <-  calcslope(rbrick, delta_t = delta_t_step) # vocc::calcslope for comparison
out <- left_join(out, slopedat, by = c("x", "y")) %>% select(-icell)
out$C_per_decade <- out$slope * 10
out$km_per_decade <- (out$distance/delta_t)*10 
out
}


make_vector_data (predictions, 
  ssid = c(1, 3),
  start_year = 2005,
  input_cell_size = 2, 
  scale_fac = 2,
  delta_t_total = 10,
  delta_t_step = 2,
  time_slices = 7,
  indices = c(1, 1, 2, 2, 2, 3, 3),
  thresholds = c(0.75)
  )
```
